#! /bin/sh

DIRT_BRANCH_DEF="$(git rev-parse --show-toplevel)/branch.def"
# If running under jenkins, we may have a detached head, but we know the
# current branch from the environment
if [ -n "$CHANGE_BRANCH" ]; then
    current_branch="$CHANGE_BRANCH"
elif [ -n "$BRANCH_NAME" ]; then
    current_branch="$BRANCH_NAME"
else
    current_branch="$(git rev-parse --abbrev-ref HEAD)"
fi
current_branch_id="$(awk "/$current_branch/ {print \$2}" < "$DIRT_BRANCH_DEF")"
current_timestamp="$(git log -n 1 --pretty=format:%ct%n .)"

dirtfile="$(dirname "$2")/$(basename "$2" .in)"
exec 3> "${dirtfile}.new"

case "$1" in 
    --smudge)
        while read line; do
            echo "$line" | \
            sed -e "s/DIRT_TIMESTAMP=.*/DIRT_TIMESTAMP=${current_timestamp:-0}/" \
                -e "s/DIRT_BRANCH_ID=.*/DIRT_BRANCH_ID=${current_branch_id:-0}/"\
                1>&3
            echo "$line"
        done
        exec 3>&-
        if [ -f "$dirtfile" ] && cmp -s "$dirtfile" "$dirtfile.new"; then
            rm -f "$dirtfile".new
        else
            mv "$dirtfile.new" "$dirtfile"
        fi
        ;;
    --clean)
        cat
        ;;
esac

